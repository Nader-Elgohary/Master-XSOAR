category: Data Enrichment & Threat Intelligence
commonfields:
  id: PassiveTotal v2
  version: -1
configuration:
- defaultvalue: https://api.passivetotal.org
  display: API URL
  name: url
  required: true
  type: 0
- display: Username
  name: username
  required: true
  type: 0
- display: API Secret
  name: secret
  required: true
  type: 4
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- additionalinfo: All the PassiveTotal API calls would timeout if the response is
    not returned within the configured time interval. Default is 20.
  defaultvalue: "20"
  display: HTTP(S) Request Timeout (in seconds)
  name: request_timeout
  required: false
  type: 0
contentitemexportablefields:
  contentitemfields:
    fromServerVersion: 5.0.0
    itemVersion: 2.0.11
    packID: PassiveTotal
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Analyze and understand threat infrastructure from a variety of sources-passive
  DNS, active DNS, WHOIS, SSL certificates and more-without devoting resources to
  time-intensive manual threat research and analysis.
detaileddescription: |-
  ### Partner Contributed Integration
  #### Integration Author: RiskIQ
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [paloaltonetworks@riskiq.net](mailto:paloaltonetworks@riskiq.net)
  - **URL**: [https://www.riskiq.com/resources/support/](https://www.riskiq.com/resources/support/)
  ***
  Generate a RiskIQ PassiveTotal API credentials
  ------------------------------------------
  RiskIQ PassiveTotal works best for existing enterprise clients, though is functional for free clients as well. In order to leverage the functionality within this application, users must first register for an account on [RiskIQ Community](https://community.riskiq.com/) using a corporate email address. Once verified, API keys can be found within the [Account Settings](https://community.riskiq.com/settings) page.


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/passive-total-v2)
display: PassiveTotal v2 (Partner Contribution)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyVpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDYuMC1jMDAyIDc5LjE2NDM2MCwgMjAyMC8wMi8xMy0wMTowNzoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjEgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUU5NDlFRTU5QTI2MTFFQTk2OTU5MkZBMDA4QzVCRTAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUU5NDlFRTY5QTI2MTFFQTk2OTU5MkZBMDA4QzVCRTAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowQTg5NTgzODk5Q0UxMUVBOTY5NTkyRkEwMDhDNUJFMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1RTk0OUVFNDlBMjYxMUVBOTY5NTkyRkEwMDhDNUJFMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PrDuRKsAAA1OSURBVHja7FsJdFRFFq2/dv/es4ckZiEJCIRVNgHHDVFZFD2KEBEdZERxUBFUQNARFDCKwDi4goPAgDIjDLIoCEcMAiYEkDUhO0mTdFbS6b3/Nq/ijweSTtKR4bic/865VPfvqt/169Z7777qQMiyjFT74xqpLoFKsGoqwaqpBKumEqyaSrBqKsGqqQSrBKumEqyaSrBqKsGqXWOjW14gCKLDQeELvqU5DWuQtCxDcRrJoGW856b1cKnL+etbyx+PiFYX2iHY+OI3z4DLv2rUaUIZvRbJBh2iDBxKNGpQhIaS/G7vAZfHl75n8vVV6lL/jgjuuuo4K/PiEaNeMyAhNhRxDI1YmkQUSSBbowcRooTiww3IomORwAt8QXndxB0TU7eqy/07ITjtk9yCcIshRUMRSEuRyOv2uf0+/hiMzWcoQm/Wa4ZqWDohIcpEsNDH5RPkE+crx+2b0mOXuuS/cYITV5/6ICrKPJ0jgVinR66qqN9UW++Y4si4Q7q838j1uUNjI027k6LNIT5BQuXVTu/J4uqw03/t51aX/TdKcJcVx7TmcLPTzDFUY1UDsl6oXhNm0n1NmfRJhFEXxnCMzkxTPgNF2HU0aWWRbIswsFsNOo2u2uFDR/IrP8qf0Xe6uuy/HsF0u70F8RGKoSl7XSOy19jRzAmDH/f4hEc9fsFn94mOS4IsOv1SJPRkm2oumkZ2HjkvXGyw0iTZxcswE+GySvA1tkeyHWnQhAK+B0hBE8wyzGhJEFHVhWqUkhgFwooiAAzkXCYaIYNfEGW/IBPVdq/TwYsNMCQOUrAhwsxpMovryngI1V1WnYisfLZ/tUrDNSN3PDSDAI2AnoAPgiJ48s7yTbVu//j8KicQSyNSz6GyakeN3y/s9nj5zUYdm7ludJwH9x29qaAfL6N7wNtH6nRsdJhBk3pbamT0V0U1LggZe7q8e3JM5cy+FYG+J3rRoW7Q9OngOUSAF1AJyLO9MtzbskPM4sMGKOFmIgIdsC4YdqTl50lLf7BA8JoGKWg0tD0hE4VKBEFDWw95qRhwAJFoXemsgedajX3/ZDL060+Q5L6iJ3o3tDXJvv8pImWSGEFSZCRBkzxDk99k3xnXpEFCpv6rpxAds6x7WsL7Oeldvwo0vs+np0JFRKyAed2FKBSG9BxlMWplHUvzJEWUkYj4eM+wiIyWfqisTwyguMODDmzpO8qeT44NmVRfVINklwdxLI0qCy9Oz3r4Tx8F6r87PfVHaDAWDVlzVl+O0P7+yVE9ByWENvxoc/TjPf6NMe+dHlkxo7cUYDjegW92YtNWxiw6dEfFK8PPtizTAUsA8wFXEJy45MhAaPCihis7/SigBuADRABuALwAmJO04tiHsEmeLXnuBv9ltxgN+Dugv/Kcrazf54XJsHE2K950BjCxmVxsjE5r4GV5HF6uQONT3sueVVNWm0HTFI3MemSy6Fw0TbpIkhRkRJggtabAvN4cdaRmLnS/Y++NEceUoRzACigFXNchwfdtu0DHRhiXYq2lYSgEXwB7hESuCzX+YFY/a1ovV9Tiw90uVDboxw/vFmYONVhdLt+tPo9/Kny8pp2hSeCZpW19CJ4eo2yEyYB1ykIGa+sUct8ALC6dO8R3xQZ4+yg+sh2rkPgk4DTgvWBvnrY5f5ISGk3KMz5zYky85wo3M2rdbZUT1684tNBaXLXIYODk0NjQvZoI8/TscUlXrAUQ2xU20CJ4+TDgW3h/C5B8HF5vUDagDvBFhwSzLDVJr2WaRBPHUqKMWcaZW5JGKQvVriW/nUMiXjSDnCMPn7KS4WnX5VMkF+fR0E90QHC7BuRXAMlPwcv7AQPBi6PAizs8MQPvxSKwF+Bi6byhCwL1KZ0zCEeWLxNX5GRhHQHeeyyYOfVan6sHD8CbAm9eB2DSqfu7fhaorykuzNNgbU1xz1WHUusKba9pTHopNCF8wsk/9/si0HggE4ffyUBsIbSvAlYDbtww2IjnvrO53/oWKppsTTB9Z/PrkvLajUAwwpBE8eZgHjrMonsopYuZTImxIMHjqWUlqZYXJdgszKDY175jrkZQAMlOaOqUt5Ygh+FVxU8dlrj0h67tdYT8W1UyKzhye6w7h3VDjkIu9qT+Jx9I/qyt/pau0QEd2GN3r5YFkeg6oOuqc22Qe7nZqxpe91xyFcHLoUB2r476tyIYqqKmOG675EJFhZUvkhpGJDHBvNAlYs7unh16TJRpXup1oYgCOd3o9O4XJPk4jEXu+ka+Mf8CdzUEgwcPUfIM9paSYMaUzr/RqUQeLc69Scuy1iQuy3o66c2scQkZ2UMS38qOhxDdqY3X/ZOzT0OTjaMroBZw648PpRS1W5EYOREEXn0rgi85B0f2iEMhMSHvBJUCx6cKnnpHsw4Y01H/ViFaJgi8EMhqaxCqM+6qNm0ozAGFOYS1GAnR7V2Lw0JbN7t/j+2GpDBd76pLbnQiKw9RUWFvOHzCRAE82FluK4ewTbUzl1FAYFvlVBigt+It2JZAePZ3ghOcV21KTf54IJWeuDynBLb7fgIRK8GL89q4T2jKmjPbFGGIRRrOs/GAtSCyJgDJ7f4/IIqhWqUUv9NjDAHvhhBsDfZhBI+vORokdppgNy86vbyEaqoa6Ki5e1IIinoS1NsJNioUNWSfHRo5b+/d1UtHBZT5eprabq1zo727jyHWZDhuXTiizLjlQjf81K78cgdsEKmduXzYwVx5xWtWA7mbO+Nx4MV4M8yHEL0QWhymU3GuBUThAztAAmCAsgEeS1p57GbIw1kBbrUdYAAcUMQOFlWHAQ8A3sIqvL15aPWsM9DJExdqIDoVyqSfHUXsNMEOv5jb6BFuEyQJiT5+YUF60qOpm0sOa2MihjWFlMrabTErc+Irnht4hbeN3V259ZLTG3vw4DlEEYRE6rUPDttSoq8VxLG83WXn6xqTMc/tzOUvgMJAIlMRFLj2nQl5+MQvDfEgsvCCFCi4MrUszyGVUmmZQtSDAW6BlerfAK/nPtYT36ui18bz90K7DzAb6uBSyMP/aOv7dWZtq2saA+eCCGmEfJoIXlwazHOIfqH53KCw0znY6Re3NPoExJkMyGerTY99eX93uDyOZGifJjoMCU63xtfoKkhcm/dzzXXL1rK1NlvD+O8O5SERwrEm3JxR/vLwYrtHmE96/RH27NxagmG+df93utDOXHKAvAMBgMuPuUqduwvCePy1OBEqnT0QR5d3lbdtfcfEwmlpr52f2utnzzk7uftBaKYob1f12Vp8b1vfYQjRGVsRbOJOSnzT7aYFM88Bn5/jBB+f0nwE0WmCM++7LtPm9Febwi1I9PhoPy8e9Z4rjYaP7jGkxgtKDjCBdxemrC94oNfa3Kz8POvU83nWpjCjDTVmVi4YPq/vx+dmC42uGXUni0o4mkrUajXLr0I94/D3kRJOv4YSKVgFjcukOYCspKU/jAii+y1KW9HG5wWBLp6Z1O1zaF5S1nNzv+2lgwP1M4bpsVNcEY45i+Fpn8ODReML4MW3d6iibQ0lUHLhUPApeHxBpwluWlC/MNYlISm2Twom0+ijqFP86eLZtCR/zJgNEinJiKhvZB15Zf8uzysf7Gj4KfLqTLqCSJbe2m3JkS9ry2sera2sM3gZOtmvZVfUbUj/7iqdDCvXvbhCwbkQSGaDHIcFGl7wTMjBm0BF3w4qWtvioCMEQvQMeLlJubSxs5MDgZWhpBJcKezsv6usVUnGcoyepIgrDlnynr/pFBui/0yUZRpCyB4geRU+1Li8z+AdxczALXkZ8csPeUmSiDInRObiw5Rg5hWQ4DMPJR4FkqdY0pJFzsQhSRApUs+NkiX5KVN0BKl1g2ap/elIVhcZgkKSY2SdxVDhsbtSK+udK2sbXeO8vNibRASt1TBrKb3mpasNoeDFOHpMwFER8Cdc08csPtyhOAGBNU/J71jBTlLypRvKJCuUSSVQJmFvrVfI0QMWgMD64hdO81l8YKIcf341eI9V30r0aKnaltf2D4vEh0DvAMkkL8vP8DIquimzSh6076KYtq1Qqqlo8FcVVr1gjjJpkgY2Rec4RSx2aO3+HgziqhcpCNs9tvpk2i8iWQcbX6dBFKdBxE8HXDiMO+3ZebxGEELcHGwGLYMIksBCq5QmyUXVS277Zwe1bYjiZeVAoi+IWpiDXRmrTLakYuEwUfmxgYXrwyAAFlsXDCsL8GMDDU86AJ6vJ7Tx8JhmCUpCaLHIqQOch+1+qHTWwJoAPzaYoV8EQZLlRU/0bneOkIMpkiITCZokGJqsyr4zztEU+7+vomBdkgQ7X3Xw7lhHoLG3H67W4FQE8XEUaBmLzy9Sfi/8I4p1BiO3g9EyOLKkA2YoaWQohOnylqo8aIKbLeH903G0j39YZpnrkYaxkCzjgAcolAVxr21nZhKI9RGURhul51gSSC4Dkg8yFLmrbtlIr/qD3v/XIHxTSrk2RvlRYwSQbA+aYNX+WKb+4btKsGoqwaqpBKumEqyaSrBqKsGqqQSrBKumEqyaSrBqKsGqqQSrdlX2PwEGALRgVkJ3NbzRAAAAAElFTkSuQmCC
name: PassiveTotal v2
script:
  commands:
  - arguments:
    - description: Query value to use in your request.
      name: query
      required: true
    - auto: PREDEFINED
      description: 'WHOIS field to execute the search on: domain, email, name, organization,
        address, phone, nameserver.'
      name: field
      predefined:
      - domain
      - email
      - name
      - organization
      - address
      - phone
      - nameserver
      required: true
    description: Gets WHOIS information records based on field matching queries.
    name: pt-whois-search
    outputs:
    - contextPath: Domain.Name
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: Domain.WHOIS.CreationDate
      description: The date that the domain was created.
      type: Date
    - contextPath: Domain.WHOIS.UpdatedDate
      description: The date that the domain was last updated.
      type: Date
    - contextPath: Domain.WHOIS.ExpirationDate
      description: The expiration date of the domain.
      type: Date
    - contextPath: Domain.WHOIS.NameServers
      description: Name servers of the domain.
      type: String
    - contextPath: Domain.Organization
      description: The organization of the domain.
      type: String
    - contextPath: Domain.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.Registrant.Phone
      description: The phone number for receiving abuse reports.
      type: String
    - contextPath: Domain.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Registrar.Name
      description: 'The name of the registrar, for example: ''GoDaddy''.'
      type: String
    - contextPath: Domain.WHOIS.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Phone
      description: The phone number for receiving abuse reports.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.domain
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: PassiveTotal.WHOIS.registrar
      description: The name of the registrar of the domain
      type: String
    - contextPath: PassiveTotal.WHOIS.whoisServer
      description: WHOIS server name where the details of domain registrations belong
      type: String
    - contextPath: PassiveTotal.WHOIS.registered
      description: The date that the domain was registered.
      type: Date
    - contextPath: PassiveTotal.WHOIS.expiresAt
      description: The expiration date of the domain.
      type: Date
    - contextPath: PassiveTotal.WHOIS.registryUpdatedAt
      description: The date when registry was last updated.
      type: Date
    - contextPath: PassiveTotal.WHOIS.lastLoadedAt
      description: Last loaded date of WHOIS database.
      type: Date
    - contextPath: PassiveTotal.WHOIS.nameServers
      description: Name servers of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.organization
      description: The organization of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.name
      description: Name of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.telephone
      description: Telephone number fetched from whois details of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.contactEmail
      description: Contact Email address of the domain owner
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantEmail
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantFax
      description: The fax number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantName
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantOrganization
      description: The organizations of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantStreet
      description: The street of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantCity
      description: The city of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantState
      description: The state of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantPostalCode
      description: The postal code of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantCountry
      description: The country of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantTelephone
      description: The telephone number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminEmail
      description: The email address of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminFax
      description: The fax number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminName
      description: The name of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminOrganization
      description: The organizations of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminStreet
      description: The street of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminCity
      description: The city of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminState
      description: The state of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminPostalCode
      description: The postal code of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminCountry
      description: The country of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminTelephone
      description: The telephone number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingEmail
      description: The email address of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingFax
      description: The fax number of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingName
      description: The name of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingOrganization
      description: The organizations of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingStreet
      description: The street of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingCity
      description: The city of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingState
      description: The state of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingPostalCode
      description: The postal code of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingCountry
      description: The country of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingTelephone
      description: The telephone number of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.techEmail
      description: The email address of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techFax
      description: The fax number of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techName
      description: The name of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techOrganization
      description: The organizations of domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techStreet
      description: The street of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techCity
      description: The city of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techState
      description: The state of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techPostalCode
      description: The postal code of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techCountry
      description: The country of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techTelephone
      description: The telephone number of the domain tech.
      type: String
  - arguments:
    - description: 'Query value to use in the request. For example: riskiq.com, 1.1.1.1'
      name: query
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: |-
        Whether to return historical results.
        Valid values: true, false.
      name: history
      predefined:
      - "true"
      - "false"
    description: Gets WHOIS information records based on queries.
    name: pt-get-whois
    outputs:
    - contextPath: PassiveTotal.WHOIS.domain
      description: 'The domain name. For example: ''google.com''.'
      type: String
    - contextPath: PassiveTotal.WHOIS.registrar
      description: The name of the registrar of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.whoisServer
      description: WHOIS server name where the details of domain registrations belong.
      type: String
    - contextPath: PassiveTotal.WHOIS.registered
      description: The date that the domain was registered.
      type: Date
    - contextPath: PassiveTotal.WHOIS.expiresAt
      description: The expiration date of the domain.
      type: Date
    - contextPath: PassiveTotal.WHOIS.registryUpdatedAt
      description: The date when the registry was last updated.
      type: Date
    - contextPath: PassiveTotal.WHOIS.lastLoadedAt
      description: Last loaded date of WHOIS database.
      type: Date
    - contextPath: PassiveTotal.WHOIS.nameServers
      description: Name servers of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.organization
      description: The organization of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.name
      description: Name of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.telephone
      description: Telephone number fetched from whois details of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.contactEmail
      description: Contact Email address of the domain owner.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantEmail
      description: The email address of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantFax
      description: The fax number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantName
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantOrganization
      description: The organizations of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantStreet
      description: The street of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantCity
      description: The city of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantState
      description: The state of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantPostalCode
      description: The postal code of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantCountry
      description: The country of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantTelephone
      description: The telephone number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminEmail
      description: The email address of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminFax
      description: The fax number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminName
      description: The name of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminOrganization
      description: The organizations of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminStreet
      description: The street of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminCity
      description: The city of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminState
      description: The state of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminPostalCode
      description: The postal code of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminCountry
      description: The country of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminTelephone
      description: The telephone number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingEmail
      description: The email address of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingFax
      description: The fax number of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingName
      description: The name of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingOrganization
      description: The organizations of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingStreet
      description: The street of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingCity
      description: The city of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingState
      description: The state of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingPostalCode
      description: The postal code of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingCountry
      description: The country of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingTelephone
      description: The telephone number of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.techEmail
      description: The email address of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techFax
      description: The fax number of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techName
      description: The name of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techOrganization
      description: The organizations of domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techStreet
      description: The street of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techCity
      description: The city of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techState
      description: The state of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techPostalCode
      description: The postal code of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techCountry
      description: The country of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techTelephone
      description: The telephone number of the domain tech.
      type: String
  - arguments:
    - default: true
      description: Domain or IP address you want to search components for.
      name: query
      required: true
    - description: Filter for records whose last seen is after this datetime. It accepts
        "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: start
    - description: Filter for records whose first seen is before this datetime. It
        accepts "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: end
    description: Retrieves the host attribute components for a domain or IP address.
      Maximum 2000 records are fetched.
    name: pt-get-components
    outputs:
    - contextPath: Domain.Name
      description: 'The domain name, for example: "google.com".'
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: IP.Address
      description: The IP Address of the component.
      type: String
    - contextPath: PassiveTotal.Component.firstSeen
      description: The date and time when the component was first observed.
      type: Date
    - contextPath: PassiveTotal.Component.lastSeen
      description: The date and time when the component was most recently observed.
      type: Date
    - contextPath: PassiveTotal.Component.version
      description: The current version of component.
      type: String
    - contextPath: PassiveTotal.Component.category
      description: The category under which the component falls.
      type: String
    - contextPath: PassiveTotal.Component.label
      description: The value of the component.
      type: String
    - contextPath: PassiveTotal.Component.hostname
      description: The hostname of the component.
      type: String
    - contextPath: PassiveTotal.Component.address
      description: The IP address of the component.
      type: String
  - arguments:
    - default: true
      description: Domain or IP address you want to search trackers for.
      name: query
      required: true
    - description: Filter for records whose last seen is after this datetime. It accepts
        "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: start
    - description: Filter for records whose first seen is before this datetime. It
        accepts "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: end
    description: Retrieves the host attribute trackers for a domain or IP address.
      Maximum 2000 records are fetched.
    name: pt-get-trackers
    outputs:
    - contextPath: Domain.Name
      description: 'The domain name, for example: "google.com".'
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: IP.Address
      description: The IP Address of the component.
      type: String
    - contextPath: PassiveTotal.Tracker.firstSeen
      description: The date and time when the tracker was first observed.
      type: Date
    - contextPath: PassiveTotal.Tracker.lastSeen
      description: The date and time when the tracker was most recently observed.
      type: Date
    - contextPath: PassiveTotal.Tracker.attributeValue
      description: The value of the tracker.
      type: String
    - contextPath: PassiveTotal.Tracker.attributeType
      description: The type under which the tracker falls.
      type: String
    - contextPath: PassiveTotal.Tracker.hostname
      description: The hostname of the tracker.
      type: String
    - contextPath: PassiveTotal.Tracker.address
      description: The IP address of the tracker.
      type: String
  - arguments:
    - default: true
      description: The domain or IP being queried.
      name: query
      required: true
    - description: Filter for records whose last seen is after this datetime. It accepts
        "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: start
    - description: Filter for records whose first seen is before this datetime. It
        accepts "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: end
    description: Retrieves the passive DNS results from active account sources.
    name: pt-get-pdns-details
    outputs:
    - contextPath: PassiveTotal.PDNS.resolve
      description: The host or ip address that indicates resolve in Passive DNS record.
      type: String
    - contextPath: PassiveTotal.PDNS.resolveType
      description: The type of the resolve. I.e domain, ip, host, etc.
      type: String
    - contextPath: PassiveTotal.PDNS.value
      description: The value of the Passive DNS record.
      type: String
    - contextPath: PassiveTotal.PDNS.source
      description: Source of the passive DNS records.
      type: String
    - contextPath: PassiveTotal.PDNS.firstSeen
      description: First seen timestamp of the passive DNS record.
      type: String
    - contextPath: PassiveTotal.PDNS.lastSeen
      description: Last seen timestamp of the passive DNS record.
      type: String
    - contextPath: PassiveTotal.PDNS.collected
      description: The date when a passive DNS record is collected.
      type: String
    - contextPath: PassiveTotal.PDNS.recordType
      description: The type of the passive DNS record. I.e CNAME, SOA, A, etc
      type: String
    - contextPath: PassiveTotal.PDNS.recordHash
      description: The hash value of the passive DNS record.
      type: String
    - contextPath: Domain.Name
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: IP.Address
      description: The IP Address of the component.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
  - arguments:
    - auto: PREDEFINED
      description: "Field by which to search. \n\nAllowed values: issuerSurname, subjectOrganizationName,
        issuerCountry, issuerOrganizationUnitName, fingerprint, subjectOrganizationUnitName,
        serialNumber, subjectEmailAddress, subjectCountry, issuerGivenName, subjectCommonName,
        issuerCommonName, issuerStateOrProvinceName, issuerProvince, subjectStateOrProvinceName,
        sha1, subjectStreetAddress, subjectSerialNumber, issuerOrganizationName, subjectSurname,
        subjectLocalityName, issuerStreetAddress, issuerLocalityName, subjectGivenName,
        subjectProvince, issuerSerialNumber, issuerEmailAddress"
      name: field
      predefined:
      - issuerSurname
      - subjectOrganizationName
      - issuerCountry
      - issuerOrganizationUnitName
      - fingerprint
      - subjectOrganizationUnitName
      - serialNumber
      - subjectEmailAddress
      - subjectCountry
      - issuerGivenName
      - subjectCommonName
      - issuerCommonName
      - issuerStateOrProvinceName
      - issuerProvince
      - subjectStateOrProvinceName
      - sha1
      - subjectStreetAddress
      - subjectSerialNumber
      - issuerOrganizationName
      - subjectSurname
      - subjectLocalityName
      - issuerStreetAddress
      - issuerLocalityName
      - subjectGivenName
      - subjectProvince
      - issuerSerialNumber
      - issuerEmailAddress
      required: true
    - description: Field value for which to search.
      name: query
      required: true
    description: Retrieves SSL certificates for a given field value.
    name: pt-ssl-cert-search
    outputs:
    - contextPath: PassiveTotal.SSL.firstSeen
      description: Epoch timestamp when SSL certificate identified by the system.
      type: Number
    - contextPath: PassiveTotal.SSL.lastSeen
      description: The last seen epoch timestamp of the SSL certificates.
      type: Number
    - contextPath: PassiveTotal.SSL.fingerprint
      description: 'A fingerprint detail from the SSL certificates. '
      type: String
    - contextPath: PassiveTotal.SSL.sslVersion
      description: A version of the certificate.
      type: Number
    - contextPath: PassiveTotal.SSL.expirationDate
      description: The expiry date of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.issueDate
      description: Issue date of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.sha1
      description: Sha1 of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.serialNumber
      description: A serial number of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.issuerCountry
      description: The country name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerStateOrProvinceName
      description: The state or province name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerCommonName
      description: The common name of the issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerEmailAddress
      description: A contact email address of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerProvince
      description: A province of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerOrganizationUnitName
      description: An organization unit name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerSurname
      description: The surname of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerStreetAddress
      description: Street address of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerLocalityName
      description: The locality of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerSerialNumber
      description: The serial number of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerOrganizationName
      description: An organization name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerGivenName
      description: A given name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.subjectCommonName
      description: The common name of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectOrganizationName
      description: An organization name of the subject of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectOrganizationUnitName
      description: An organization unit name of the subject of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectGivenName
      description: The given name of the subject of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectSurname
      description: The surname of the subject of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectLocalityName
      description: The locality of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectEmailAddress
      description: A contact email address of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectProvince
      description: The province of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectStateOrProvinceName
      description: The state or province name of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectSerialNumber
      description: A serial number of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectStreetAddress
      description: The street address of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectCountry
      description: The country name of the subject from the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectAlternativeNames
      description: Alternative names of the subject from the certificate details.
      type: String
  - arguments:
    - description: Domain or IP address you want to search host-pairs for.
      name: query
      required: true
    - auto: PREDEFINED
      description: 'The direction of searching pair records for a given domain. Valid
        values: children, parents.'
      name: direction
      predefined:
      - children
      - parents
      required: true
    - description: Filter for records whose last seen is after this datetime. It accepts
        "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: start
    - description: Filter for records whose first seen is before this datetime. It
        accepts "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: end
    description: Retrieves the host attribute pairs related to a domain or IP address.
      Maximum 2000 records are fetched.
    name: pt-get-host-pairs
    outputs:
    - contextPath: PassiveTotal.HostPair.firstSeen
      description: The date and time when the host pair was first observed.
      type: Date
    - contextPath: PassiveTotal.HostPair.lastSeen
      description: The date and time when the host pair was most recently observed.
      type: Date
    - contextPath: PassiveTotal.HostPair.cause
      description: The cause of relation between parent and child.
      type: String
    - contextPath: PassiveTotal.HostPair.parent
      description: The hostname of the parent of the host pair.
      type: String
    - contextPath: PassiveTotal.HostPair.child
      description: The hostname of the child of the host pair.
      type: String
  - arguments:
    - default: true
      description: The domain to enrich.
      isArray: true
      name: domain
    description: Provides data enrichment for domains.
    name: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
    - contextPath: DBotScore.Type
      description: The indicator type.
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the DBot score.
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: Domain.Name
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: Domain.WHOIS.CreationDate
      description: The date that the domain was created.
      type: Date
    - contextPath: Domain.WHOIS.UpdatedDate
      description: The date that the domain was last updated.
      type: Date
    - contextPath: Domain.WHOIS.ExpirationDate
      description: The expiration date of the domain.
      type: Date
    - contextPath: Domain.WHOIS.NameServers
      description: Name servers of the domain.
      type: String
    - contextPath: Domain.Organization
      description: The organization of the domain.
      type: String
    - contextPath: Domain.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.Registrant.Phone
      description: The phone number for receiving abuse reports.
      type: String
    - contextPath: Domain.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Registrar.Name
      description: 'The name of the registrar, for example: ''GoDaddy''.'
      type: String
    - contextPath: Domain.WHOIS.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Phone
      description: The phone number for receiving abuse reports.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: PassiveTotal.Domain.domain
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: PassiveTotal.Domain.registrar
      description: The name of the registrar of the domain
      type: String
    - contextPath: PassiveTotal.Domain.whoisServer
      description: WHOIS server name where the details of domain registrations belong
      type: String
    - contextPath: PassiveTotal.Domain.registered
      description: The date that the domain was registered.
      type: Date
    - contextPath: PassiveTotal.Domain.expiresAt
      description: The expiration date of the domain.
      type: Date
    - contextPath: PassiveTotal.Domain.registryUpdatedAt
      description: The date when registry was last updated.
      type: Date
    - contextPath: PassiveTotal.Domain.lastLoadedAt
      description: Last loaded date of WHOIS database.
      type: Date
    - contextPath: PassiveTotal.Domain.nameServers
      description: Name servers of the domain.
      type: String
    - contextPath: PassiveTotal.Domain.organization
      description: The organization of the domain.
      type: String
    - contextPath: PassiveTotal.Domain.name
      description: Name of the domain.
      type: String
    - contextPath: PassiveTotal.Domain.telephone
      description: Telephone number fetched from whois details of the domain.
      type: String
    - contextPath: PassiveTotal.Domain.contactEmail
      description: Contact Email address of the domain owner
      type: String
    - contextPath: PassiveTotal.Domain.registrantEmail
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantFax
      description: The fax number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantName
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantOrganization
      description: The organizations of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantStreet
      description: The street of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantCity
      description: The city of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantState
      description: The state of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantPostalCode
      description: The postal code of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantCountry
      description: The country of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantTelephone
      description: The telephone number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.adminEmail
      description: The email address of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminFax
      description: The fax number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminName
      description: The name of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminOrganization
      description: The organizations of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminStreet
      description: The street of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminCity
      description: The city of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminState
      description: The state of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminPostalCode
      description: The postal code of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminCountry
      description: The country of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminTelephone
      description: The telephone number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.billingEmail
      description: The email address of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingFax
      description: The fax number of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingName
      description: The name of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingOrganization
      description: The organizations of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingStreet
      description: The street of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingCity
      description: The city of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingState
      description: The state of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingPostalCode
      description: The postal code of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingCountry
      description: The country of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingTelephone
      description: The telephone number of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.techEmail
      description: The email address of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techFax
      description: The fax number of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techName
      description: The name of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techOrganization
      description: The organizations of domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techStreet
      description: The street of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techCity
      description: The city of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techState
      description: The state of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techPostalCode
      description: The postal code of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techCountry
      description: The country of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techTelephone
      description: The telephone number of the domain tech.
      type: String
  - arguments:
    - description: 'Indicator value to search for in articles. For example: riskiq.com,
        1.1.1.1'
      name: query
      required: true
    - description: 'Type of the indicator. For example: domain, ip, url'
      name: type
    description: Retrieves information related to articles for a specific indicator.
    name: pt-get-articles
    outputs:
    - contextPath: PassiveTotal.Article.guid
      description: The global unique ID of the article.
      type: String
    - contextPath: PassiveTotal.Article.title
      description: The title of the article.
      type: String
    - contextPath: PassiveTotal.Article.summary
      description: The summary of the article.
      type: String
    - contextPath: PassiveTotal.Article.type
      description: The type of an article.
      type: String
    - contextPath: PassiveTotal.Article.publishedDate
      description: The date and time on which the article was published.
      type: Date
    - contextPath: PassiveTotal.Article.link
      description: The link of the article for getting more details.
      type: String
    - contextPath: PassiveTotal.Article.categories
      description: An array of categories of the article.
      type: Unknown
    - contextPath: PassiveTotal.Article.tags
      description: An array of tags for the article.
      type: Unknown
    - contextPath: PassiveTotal.Article.indicators.type
      description: The type of the indicator.
      type: String
    - contextPath: PassiveTotal.Article.indicators.count
      description: Total number of indicators of a particular type.
      type: Number
    - contextPath: PassiveTotal.Article.indicators.values
      description: An array of values related to indicators.
      type: Unknown
    - contextPath: PassiveTotal.Article.indicators.source
      description: The source of the indicator.
      type: String
  - arguments:
    - default: true
      description: IP address for which the user wants to search services for.
      name: ip
      required: true
    description: Retrieves exposed services on the recently open ports for an IP address.
    name: pt-get-services
    outputs:
    - contextPath: PassiveTotal.Service.ip
      description: IP address of the service.
      type: String
    - contextPath: PassiveTotal.Service.portNumber
      description: Port number on which recent services were running or current services
        are running.
      type: Number
    - contextPath: PassiveTotal.Service.firstSeen
      description: The date and time when the service was started for the first time
        on the port.
      type: Date
    - contextPath: PassiveTotal.Service.lastSeen
      description: The date and time when the service was most recently used on the
        port.
      type: Date
    - contextPath: PassiveTotal.Service.lastScan
      description: The date and time when the system performed the last scan to check
        whether any service is running on the port or not.
      type: Date
    - contextPath: PassiveTotal.Service.count
      description: The total number of times service was used on the port.
      type: Number
    - contextPath: PassiveTotal.Service.status
      description: The status of the service.
      type: String
    - contextPath: PassiveTotal.Service.protocol
      description: The protocol used by the service.
      type: String
    - contextPath: PassiveTotal.Service.banners.banner
      description: The description of the banner generated as a result of scanning.
        Can be in HTML format.
      type: String
    - contextPath: PassiveTotal.Service.banners.scanType
      description: The type of scan when the banner was generated.
      type: String
    - contextPath: PassiveTotal.Service.banners.firstSeen
      description: The date and time when the scan started.
      type: Date
    - contextPath: PassiveTotal.Service.banners.lastSeen
      description: The date and time when the scan ended.
      type: Date
    - contextPath: PassiveTotal.Service.banners.count
      description: The total number of times the same label was generated while scanning.
      type: Number
    - contextPath: PassiveTotal.Service.currentServices.firstSeen
      description: The date and time when the current service started.
      type: Date
    - contextPath: PassiveTotal.Service.currentServices.lastSeen
      description: The date and time when the current service was most recently used.
      type: Date
    - contextPath: PassiveTotal.Service.currentServices.version
      description: The version of the current service.
      type: String
    - contextPath: PassiveTotal.Service.currentServices.category
      description: The category of the current service.
      type: String
    - contextPath: PassiveTotal.Service.currentServices.label
      description: The label of the current service.
      type: String
    - contextPath: PassiveTotal.Service.recentServices.firstSeen
      description: The date and time when the recent service started.
      type: Date
    - contextPath: PassiveTotal.Service.recentServices.lastSeen
      description: The date and time when the recent service was most recently used.
      type: Date
    - contextPath: PassiveTotal.Service.recentServices.version
      description: The version of the recent service.
      type: String
    - contextPath: PassiveTotal.Service.recentServices.category
      description: The category of the recent service.
      type: String
    - contextPath: PassiveTotal.Service.recentServices.label
      description: The label of the recent service.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.firstSeen
      description: The timestamp in epoch when the most recent SSL certificate was
        identified by the system.
      type: Date
    - contextPath: PassiveTotal.Service.mostRecentSslCert.lastSeen
      description: The timestamp in epoch when the most recent SSL certificate was
        last used.
      type: Date
    - contextPath: PassiveTotal.Service.mostRecentSslCert.fingerprint
      description: A fingerprint detail from the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.sslVersion
      description: The version of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.expirationDate
      description: The expiry date and time  of the most recent SSL certificate in
        GMT.
      type: Date
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issueDate
      description: The date and time in GMT when the most recent SSL certificate was
        issued.
      type: Date
    - contextPath: PassiveTotal.Service.mostRecentSslCert.sha1
      description: Sha1 of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.serialNumber
      description: The serial Number of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectCountry
      description: The name of the Country of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerCommonName
      description: The common name of the issuer of most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerProvince
      description: The province of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectStateOrProvinceName
      description: The state or province name of the subject of the most recent SSL
        certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectStreetAddress
      description: The street address of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerStateOrProvinceName
      description: The state or province name of the issuer of the most recent SSL
        certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectSurname
      description: The surname of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerCountry
      description: The country of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectLocalityName
      description: The subject locality name of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectAlternativeNames
      description: List of alternative names of the subject of the most recent SSL
        certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerOrganizationUnitName
      description: The name organization unit of the issuer of the most recent SSL
        certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerOrganizationName
      description: The  organization name of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectEmailAddress
      description: Email Address of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectOrganizationName
      description: The organization name of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerLocalityName
      description: The name of the locality of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectCommonName
      description: Common name of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectProvince
      description: The province of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerGivenName
      description: The given name of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectOrganizationUnitName
      description: Subject organization unit name of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerEmailAddress
      description: The email address of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectGivenName
      description: Given name of the subject of the the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectSerialNumber
      description: The serial number of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerStreetAddress
      description: The street Address of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerSerialNumber
      description: The serial number of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerSurname
      description: The surname of the issuer of the most recent SSL certificate.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: |-
        Search cookies information by name or domain.
        Valid values:
        1. get addresses by cookie domain
        2. get addresses by cookie name
        3. get hosts by cookie domain
        4. get hosts by cookie name
      name: search_by
      predefined:
      - get addresses by cookie domain
      - get addresses by cookie name
      - get hosts by cookie domain
      - get hosts by cookie name
      required: true
    - description: Name or domain of cookie the user wants to search for.
      name: query
      required: true
    - defaultValue: "0"
      description: Page number for paging through results. Each page contains 2000
        values.
      name: page
    - auto: PREDEFINED
      defaultValue: last seen
      description: 'Field to sort the results on. Valid values: last seen, first seen.'
      name: sort
      predefined:
      - last seen
      - first seen
    - auto: PREDEFINED
      defaultValue: desc
      description: 'Order to return the results in. Valid values: asc, desc'
      name: order
      predefined:
      - desc
      - asc
    description: Retrieves cookies addresses or hostname information based on cookie
      name or domain.
    name: pt-get-cookies
    outputs:
    - contextPath: PassiveTotal.Cookie.hostname
      description: The hostname/IP of the machine on which the cookie was found.
      type: String
    - contextPath: PassiveTotal.Cookie.cookieName
      description: The name of the cookie that was found on the host.
      type: String
    - contextPath: PassiveTotal.Cookie.cookieDomain
      description: The domain from which the cookie originated from.
      type: String
    - contextPath: PassiveTotal.Cookie.firstSeen
      description: The date and time when the cookie was first observed.
      type: Date
    - contextPath: PassiveTotal.Cookie.lastSeen
      description: The date and time when the cookie was most recently observed.
      type: Date
  dockerimage: demisto/python3:3.9.5.21272
  runonce: false
  script: |2


    ''' IMPORTS '''

    from typing import Dict, Any, List, Union, Tuple, Optional
    from requests import ConnectionError
    from requests.exceptions import MissingSchema, InvalidSchema
    import urllib3
    import traceback
    import re

    # Disable insecure warnings
    urllib3.disable_warnings()

    ''' CONSTANTS '''
    DATE_TIME_FORMAT = '%Y-%m-%d %H:%M:%S'

    DATE_FORMAT = '%Y-%m-%d'

    INTEGRATION_NAME: str = 'PassiveTotal'

    DEFAULT_REQUEST_TIMEOUT = '20'

    MESSAGES: Dict[str, str] = {
        'AUTHENTICATION_ERROR': 'Unauthenticated. Check the configured Username and API secret.',
        'PAGE_NOT_FOUND_ERROR': 'No record(s) found.',
        'INTERNAL_SERVER_ERROR': 'The server encountered an internal error for PassiveTotal and was unable to complete '
                                 'your request.',
        'BAD_REQUEST_ERROR': 'An error occurred while fetching the data.',
        'REQUEST_TIMEOUT_VALIDATION': 'HTTP(S) Request timeout parameter must be a positive integer.',
        'REQUEST_TIMEOUT_EXCEED_ERROR': 'Value is too large for HTTP(S) Request Timeout.',
        'NO_RECORDS_FOUND': 'No {0} were found for the given argument(s).',
        'EMPTY_WHOIS_ARGUMENT': 'query or field argument should not be empty.',
        'EMPTY_DOMAIN_ARGUMENT': 'domain argument should not be empty.',
        'INVALID_DIRECTION_VALUE': 'The given value for direction is invalid. Supported values: children, parents.',
        'INVALID_QUERY_VALUE': 'The given value for query is invalid.',
        'MISSING_SCHEMA_ERROR': 'Invalid API URL. No schema supplied: http(s).',
        'INVALID_SCHEMA_ERROR': 'Invalid API URL. Supplied schema is invalid, supports http(s).',
        'CONNECTION_ERROR': 'Connectivity failed. Check your internet connection, the API URL or try increasing the HTTP(s)'
                            ' Request Timeout.',
        'PROXY_ERROR': 'Proxy Error - cannot connect to proxy. Either try clearing the \'Use system proxy\' check-box or '
                       'check the host, authentication details and connection details for the proxy.',
        'INVALID_VALUE_IN_FIELD_ARG': 'Invalid field type {}. Valid field types are domain, email, name, organization, '
                                      'address, phone, nameserver.',
        'INVALID_IP': 'IP is not valid. Please enter a valid IP address.',
        'EMPTY_GET_WHOIS_ARGUMENT': 'query argument should not be empty.',
        'INVALID_VALUE_IN_HISTORY_ARG': 'Invalid history value {}. Valid history values are true, false.',
        'INVALID_WHOLE_NUMBER': 'Argument {} should be 0 or a positive integer.',
        'INVALID_SINGLE_SELECT': 'Invalid argument {}. Valid values are {}.',
        'INVALID_QUERY_COOKIE_DOMAIN': 'Argument query should be a valid domain that '
                                       'does not contain any special characters other than hyphen (-) and full stop (.)',
        'INVALID_QUERY_COOKIE_NAME': 'Argument query should be a valid cookie name that does not contain '
                                     'spaces, separator character or tabs.'
    }

    URL_SUFFIX: Dict[str, str] = {
        'TEST_MODULE': '/v2/account',
        'SSL_CERT_SEARCH': '/v2/ssl-certificate/search',
        'GET_PDNS_DETAILS': '/v2/dns/passive',
        'WHOIS_SEARCH': '/v2/whois/search',
        'WHOIS_GET': '/v2/whois',
        'GET_COMPONENTS': '/v2/host-attributes/components',
        'GET_TRACKERS': '/v2/host-attributes/trackers',
        'GET_ARTICLES': '/v2/articles/indicator',
        'GET_HOST_PAIRS': '/v2/host-attributes/pairs',
        'GET_SERVICES': '/v2/services',
        "GET_ADDRESSES_BY_COOKIE_NAME": "v2/cookies/name/{0}/addresses",
        "GET_ADDRESSES_BY_COOKIE_DOMAIN": "v2/cookies/domain/{0}/addresses",
        "GET_HOSTS_BY_COOKIE_NAME": "v2/cookies/name/{0}/hosts",
        "GET_HOSTS_BY_COOKIE_DOMAIN": "v2/cookies/domain/{0}/hosts"
    }

    ISO_DATE: Dict[str, str] = {
        DATE_TIME_FORMAT: '"yyyy-mm-dd hh:mm:ss"',
        DATE_FORMAT: '"yyyy-mm-dd"'
    }

    VALID_DIRECTION_FOR_HOST_PAIRS = ['children', 'parents']

    REQUEST_TIMEOUT_MAX_VALUE = 9223372036

    COMPANY_NAME = "PaloAltoNetworks"

    PRODUCT_NAME = "XSOAR"


    class Client(BaseClient):
        """
        Client to use in integration with powerful http_request.
        It extends the base client and uses the http_request method for the API request.
        Handle some exceptions externally.
        """

        def __init__(self, base_url, request_timeout, verify, proxy, auth):
            super().__init__(base_url=base_url, verify=verify, proxy=proxy, auth=auth)
            self.request_timeout = request_timeout

        def http_request(self, method: str, url_suffix: str, json_data=None, params=None, headers=None) -> Dict[str, Any]:
            """
                Override http_request method from BaseClient class. This method will print an error based on status code
                and exceptions.

            :type method: ``str``
            :param method: The HTTP method, for example: GET, POST, and so on.

            :type url_suffix: ``str``
            :param url_suffix: The API endpoint.

            :type json_data: ``dict``
            :param json_data: The dictionary to send in a 'POST' request.

            :type params: ``dict``
            :param params: URL parameters to specify the query.

            :type headers: ``dict``
            :param headers: Headers to send in the request. If None, will use self._headers.

            :return: Depends on the resp_type parameter
            :rtype: ``dict`` or ``str`` or ``requests.Response``
            """
            try:
                if not headers:
                    headers = {}
                headers['X-RISKIQ'] = f"{COMPANY_NAME}-{PRODUCT_NAME}-{get_demisto_version_as_str()}"

                resp = self._http_request(method=method, url_suffix=url_suffix, json_data=json_data, params=params,
                                          headers=headers, timeout=self.request_timeout, resp_type='response',
                                          ok_codes=(200, 400, 401, 404, 407, 500), proxies=handle_proxy())
            except MissingSchema:
                raise ValueError(MESSAGES['MISSING_SCHEMA_ERROR'])
            except InvalidSchema:
                raise ValueError(MESSAGES['INVALID_SCHEMA_ERROR'])
            except DemistoException as e:
                if 'Proxy Error' in str(e):
                    raise ConnectionError(MESSAGES['PROXY_ERROR'])
                elif 'ConnectionError' in str(e) or 'ConnectTimeout' in str(e):
                    raise ConnectionError(MESSAGES['CONNECTION_ERROR'])
                else:
                    raise e

            # Providing errors based on status code
            status_code = resp.status_code

            if status_code != 200:
                error_message = ''
                if resp.json().get('message', ''):
                    error_message = 'Reason: {}'.format(resp.json().get('message', ''))
                status_code_message_map = {
                    400: '{} {}'.format(MESSAGES['BAD_REQUEST_ERROR'], error_message),
                    401: MESSAGES['AUTHENTICATION_ERROR'],
                    404: MESSAGES['PAGE_NOT_FOUND_ERROR'],
                    407: MESSAGES['PROXY_ERROR']
                }
                if status_code in status_code_message_map:
                    demisto.info('Response code: {}. Reason: {}'.format(status_code, status_code_message_map[status_code]))
                    raise ValueError(status_code_message_map[status_code])
                elif status_code >= 500:
                    demisto.info('Response code: {}. Reason: {}'.format(status_code, MESSAGES['INTERNAL_SERVER_ERROR']))
                    raise ValueError(MESSAGES['INTERNAL_SERVER_ERROR'])
                else:
                    resp.raise_for_status()

            return resp.json()


    ''' HELPER FUNCTIONS '''


    def get_request_timeout() -> Optional[Any]:
        """
        Validate and return the request timeout parameter.
        The parameter must be a positive integer.
        Default value is set to 20 seconds for API request timeout.

        :params req_timeout: Request timeout value.
        :return: boolean
        """
        try:
            request_timeout = demisto.params().get('request_timeout', DEFAULT_REQUEST_TIMEOUT)
            request_timeout = DEFAULT_REQUEST_TIMEOUT if not request_timeout else request_timeout
            request_timeout = int(request_timeout)
        except ValueError:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_VALIDATION'])

        if request_timeout <= 0:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_VALIDATION'])
        elif request_timeout > REQUEST_TIMEOUT_MAX_VALUE:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_EXCEED_ERROR'])

        return request_timeout


    def get_host_attribute_context_data(records: List[Dict[str, Any]]) -> Tuple[list, list]:
        """
        Prepares context data for get components and get trackers command

        :param records: API response
        :return: standard entry command results list and custom entry context
        """
        custom_ec = createContext(data=records, removeNull=True)
        standard_results: List[CommandResults] = []
        for record in records:
            if record.get('hostname'):
                hostname = record.get('hostname')
                dbot_score = Common.DBotScore(indicator=hostname, indicator_type=DBotScoreType.DOMAIN,
                                              integration_name=INTEGRATION_NAME, score=Common.DBotScore.NONE)
                if auto_detect_indicator_type(hostname) == FeedIndicatorType.Domain:
                    domain_ioc = Common.Domain(domain=hostname, dbot_score=dbot_score)
                    # add standard output with standard readable output
                    standard_results.append(CommandResults(
                        indicator=domain_ioc,
                        readable_output=tableToMarkdown('', domain_ioc.to_context().get(Common.Domain.CONTEXT_PATH))
                    ))
            elif record.get('address'):
                address = record.get('address')
                dbot_score = Common.DBotScore(indicator=address, indicator_type=DBotScoreType.IP,
                                              integration_name=INTEGRATION_NAME, score=Common.DBotScore.NONE)
                if auto_detect_indicator_type(address) == FeedIndicatorType.IP:
                    ip_ioc = Common.IP(ip=address, dbot_score=dbot_score)
                    # add standard output with standard readable output
                    standard_results.append(CommandResults(
                        indicator=ip_ioc,
                        readable_output=tableToMarkdown('', ip_ioc.to_context().get(Common.IP.CONTEXT_PATH))
                    ))

        return standard_results, custom_ec


    def get_components_hr(components: List[Dict[str, Any]]) -> str:
        """
        Prepares human readable text for get components command

        :param components: Components data response
        :return: Human readable output for components
        """

        hr_table: List[Dict[str, Any]] = []

        for component in components:
            hr_row = {
                'Hostname': component.get('hostname', ''),
                'Address': component.get('address', ''),
                'First (GMT)': component.get('firstSeen', ''),
                'Last (GMT)': component.get('lastSeen', ''),
                'Category': component.get('category', ''),
                'Value': component.get('label', ''),
                'Version': component.get('version', ''),
            }
            hr_table.append(hr_row)

        hr_headers = ['Hostname', 'Address', 'First (GMT)', 'Last (GMT)', 'Category', 'Value', 'Version']
        hr = '### Total Retrieved Record(s): {0}\n'.format(len(components))
        return hr + tableToMarkdown('COMPONENTS', hr_table, hr_headers, removeNull=True)


    def get_trackers_hr(trackers: List[Dict[str, Any]]) -> str:
        """
        Prepares human readable text for get trackers command

        :param trackers: Trackers data response
        :return: Human readable output for trackers
        """

        hr_table: List[Dict[str, Any]] = []

        for tracker in trackers:
            hr_row = {
                'Hostname': tracker.get('hostname', ''),
                'Address': tracker.get('address', ''),
                'First (GMT)': tracker.get('firstSeen', ''),
                'Last (GMT)': tracker.get('lastSeen', ''),
                'Type': tracker.get('attributeType', ''),
                'Value': tracker.get('attributeValue', '')
            }
            hr_table.append(hr_row)

        hr_headers = ['Hostname', 'Address', 'First (GMT)', 'Last (GMT)', 'Type', 'Value']
        hr = '### Total Retrieved Record(s): {0}\n'.format(len(trackers))
        return hr + tableToMarkdown('TRACKERS', hr_table, hr_headers, removeNull=True)


    def get_host_pairs_hr(host_pairs: List[Dict[str, Any]]) -> str:
        """
        Prepares human readable text for get host pairs command

        :param host_pairs: Host pairs data response
        :return: Human readable output for host pairs
        """

        hr_table: List[Dict[str, Any]] = []

        for pair in host_pairs:
            hr_row = {
                'Parent Hostname': pair.get('parent', ''),
                'Child Hostname': pair.get('child', ''),
                'First (GMT)': pair.get('firstSeen', ''),
                'Last (GMT)': pair.get('lastSeen', ''),
                'Cause': pair.get('cause', '')
            }
            hr_table.append(hr_row)

        hr_headers = ['Parent Hostname', 'Child Hostname', 'First (GMT)', 'Last (GMT)', 'Cause']
        hr = '### Total Retrieved Record(s): {0}\n'.format(len(host_pairs))
        return hr + tableToMarkdown('HOST PAIRS', hr_table, hr_headers, removeNull=True)


    def get_common_arguments(args: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validates the common arguments and prepares parameter dictionary
        This method is used in commands "get-trackers", "get-components", "get-host-pairs"

        :param args: The general arguments
        :return: dict of params or message describing error in argument validation
        """
        params: Dict[str, Any] = {}

        if not args.get('query'):
            raise ValueError(MESSAGES['INVALID_QUERY_VALUE'])
        params['query'] = args.get('query')

        date_arguments = ['start', 'end']
        for argument in date_arguments:
            if args.get(argument):
                params[argument] = args.get(argument, '')

        return params


    def get_valid_whois_search_arguments(args: Dict[str, Any]) -> Tuple[str, str]:
        """
        Get and Validate arguments for pt-whois-search command.

        :param args: it contain arguments of pt-whois-search command
        :return: validated arguments 'query' and 'field'
        """
        query = args.get('query', '')
        field = args.get('field', '')
        if query.strip() == '' or field.strip() == '':
            raise ValueError(MESSAGES['EMPTY_WHOIS_ARGUMENT'])
        if field not in ('domain', 'email', 'name', 'organization', 'address', 'phone', 'nameserver'):
            raise ValueError(MESSAGES['INVALID_VALUE_IN_FIELD_ARG'].format(field))
        return query, field


    def get_valid_get_whois_arguments(args: Dict[str, Any]) -> Tuple[str, str]:
        """
        Get and Validate arguments for pt-get-whois command.

        :param args: it contain arguments of pt-get-whois command
        :return: validated arguments 'query' and 'history'
        """
        query = args.get('query', '').strip()
        arg_history = args.get('history', '').strip()
        history = arg_history.lower()
        if query == '':
            raise ValueError(MESSAGES['EMPTY_GET_WHOIS_ARGUMENT'])
        if history and history not in ('true', 'false'):
            raise ValueError(MESSAGES['INVALID_VALUE_IN_HISTORY_ARG'].format(arg_history))
        return query, history


    def nested_to_flat(src: Dict[str, Any], key: str) -> Dict[str, Any]:
        """
        Convert nested dictionary to flat by contact the keys. Also converts keys in pascal string format.

        :param src: sub-dictionary that needs to convert from nested to flat. (e.g. "foo": {"bar": "some-value"})
        :param key: main key of sub-dictionary (e.g "foo")
        :return: flat dictionary with pascal formatted keys (e.g. {"FooBar": "some-value"})
        """

        flat_dict: Dict[str, str] = {}
        for sub_key, sub_value in src.items():
            pascal_key = '{}{}'.format(key, sub_key[0].upper() + sub_key[1:])
            flat_dict[pascal_key] = sub_value

        return flat_dict


    def prepare_context_dict(response_dict: Dict[str, Any],
                             keys_with_hierarchy: tuple = (),
                             exclude_keys: tuple = ()) -> Dict[str, str]:
        """
        Prepare the context dictionary as per the standards.

        :param response_dict: dictionary getting from API response that contains sub-dictionaries
        :param keys_with_hierarchy: list of keys that contains sub-dictionary as its value.
        :param exclude_keys: keys need to exclude.
        :return: single level dictionary
        """
        simple_dict: Dict[str, str] = {}
        for key, value in response_dict.items():
            if key in keys_with_hierarchy:
                simple_dict.update(nested_to_flat(response_dict.get(key, {}), key))
            elif key not in exclude_keys:
                simple_dict[key] = value
        return simple_dict


    def get_context_for_whois_commands(domains: List[Dict[str, Any]]) -> Tuple[list, list]:
        """
        Prepare context for whois and domain reputation commands.

        :param domains: list of domains return from response
        :return: command results for standard context and custom context for whois and domain reputation command
        """
        command_results: List[CommandResults] = []
        custom_context: List[Dict[str, Any]] = []
        # set domain standard context
        for domain in domains:
            # set domain standard context
            if auto_detect_indicator_type(domain.get('domain', '')) == FeedIndicatorType.Domain:
                standard_context_domain = Common.Domain(
                    domain=domain.get('domain', ''),
                    creation_date=domain.get('registered', ''),
                    updated_date=domain.get('registryUpdatedAt', ''),
                    expiration_date=domain.get('expiresAt', ''),
                    name_servers=domain.get('nameServers', ''),
                    organization=domain.get('organization', ''),
                    admin_name=domain.get('admin', {}).get('name', ''),
                    admin_email=domain.get('admin', {}).get('email', ''),
                    admin_phone=domain.get('admin', {}).get('telephone', ''),
                    admin_country=domain.get('admin', {}).get('country', ''),
                    registrar_name=domain.get('registrar', ''),
                    registrant_email=domain.get('registrant', {}).get('email', ''),
                    registrant_name=domain.get('registrant', {}).get('name', ''),
                    registrant_phone=domain.get('registrant', {}).get('telephone', ''),
                    registrant_country=domain.get('registrant', {}).get('country', ''),
                    dbot_score=Common.DBotScore(
                        indicator=domain.get('domain', ''),
                        indicator_type=DBotScoreType.DOMAIN,
                        integration_name=INTEGRATION_NAME,
                        score=Common.DBotScore.NONE
                    )
                )
                # add standard output with standard readable output
                command_results.append(CommandResults(
                    indicator=standard_context_domain,
                    readable_output=tableToMarkdown('',
                                                    standard_context_domain.to_context().get(Common.Domain.CONTEXT_PATH))
                ))

            # set custom context for whois commands
            custom_context.append(
                prepare_context_dict(
                    response_dict=domain,
                    keys_with_hierarchy=('registrant', 'admin', 'billing', 'tech'),
                    exclude_keys=('zone', 'rawText')
                )
            )
        return command_results, createContext(custom_context, removeNull=True)


    def get_context_for_get_whois_commands(domains: List[Dict[str, Any]]) -> list:
        """
        Prepare context for pt-get-whois command.

        :param domains: list of domains return from response
        :return: command results for custom context for whois command
        """
        custom_context: List[Dict[str, Any]] = []
        # set domain standard context
        for domain in domains:
            custom_context.append(
                prepare_context_dict(
                    response_dict=domain,
                    keys_with_hierarchy=('registrant', 'admin', 'billing', 'tech'),
                    exclude_keys=('zone', 'rawText')
                )
            )
        return createContext(custom_context, removeNull=True)


    def prepare_hr_cell_for_whois_info(domain_info: Dict[str, Any]) -> str:
        """
        Prepare cell information for Registrant, Admin, Billing and Tech columns.

        :param domain_info: domain information as a directory
        :return: domain information as a readable format
        """
        hr_cell_info: List[str] = []
        for key, value in domain_info.items():
            hr_cell_info.append('**{}:** {}'.format(key[0].upper() + key[1:], value))
        return ',\n'.join(hr_cell_info)


    def get_human_readable_for_whois_commands(domains: List[Dict[str, Any]], is_reputation_command=False):
        """
        Prepare readable output for whois commands

        :param domains: list of domains return from response
        :param is_reputation_command: true if the command is execute for reputation command else false, default is false
        :return: markdown of whois commands based on domains passed
        """
        hr_table_content: List[Dict[str, Any]] = []
        table_name = 'Domain(s)'
        for domain in domains:
            hr_row = {
                'Domain': domain.get('domain', ''),
                'WHOIS Server': domain.get('whoisServer', ''),
                'Registrar': domain.get('registrar', ''),
                'Contact Email': domain.get('contactEmail', ''),
                'Name Servers': ', '.join(domain.get('nameServers', [])),
                'Creation Date (GMT)': domain.get('registered', ''),
                'Expire Date (GMT)': domain.get('expiresAt', ''),
                'Updated Date (GMT)': domain.get('registryUpdatedAt', ''),
                'Last Scanned (GMT)': domain.get('lastLoadedAt', ''),
                'Registrant': prepare_hr_cell_for_whois_info(domain.get('registrant', {})),
                'Admin': prepare_hr_cell_for_whois_info(domain.get('admin', {})),
                'Billing': prepare_hr_cell_for_whois_info(domain.get('billing', {})),
                'Tech': prepare_hr_cell_for_whois_info(domain.get('tech', {}))
            }
            hr_table_content.append(hr_row)

        hr = ''
        if not is_reputation_command:
            hr += '### Total Retrieved Record(s): ' + str(len(domains)) + '\n'
            table_name = 'Associated Domains'
        hr += tableToMarkdown(
            name=table_name,
            t=hr_table_content,
            headers=['Domain', 'WHOIS Server', 'Registrar', 'Contact Email', 'Name Servers', 'Registrant', 'Admin',
                     'Billing', 'Tech', 'Creation Date (GMT)', 'Expire Date (GMT)', 'Updated Date (GMT)',
                     'Last Scanned (GMT)'],
            removeNull=True
        )
        return hr


    def get_human_readable_for_articles_commands(articles: List[Dict[str, Any]]):
        """
        Prepare readable output for pt-get-articles command

        :param articles: list of articles return from response
        :return: markdown of article command based on articles passed
        """
        hr_table_content: List[Dict[str, Any]] = []
        table_name = 'Article(s)'
        for article in articles:
            hr_row = {
                'GUID': article.get('guid', ''),
                'Title': article.get('title', ''),
                'Summary': article.get('summary', ''),
                'Type': article.get('type', ''),
                'Tags': ', '.join(article.get('tags', [])) if article.get('tags', []) else '',
                'Categories': ', '.join(article.get('categories', [])) if article.get('categories', []) else '',
                'Article Link': article.get('link', ''),
                'Published Date (GMT)': article.get('publishedDate', '')
            }
            hr_table_content.append(hr_row)

        hr = '### Total Retrieved Record(s): ' + str(len(articles)) + '\n'
        hr += tableToMarkdown(
            name=table_name,
            t=hr_table_content,
            headers=['GUID', 'Title', 'Summary', 'Type', 'Tags', 'Categories', 'Article Link', 'Published Date (GMT)'],
            removeNull=True
        )
        return hr


    def prepare_human_readable_dict_for_ssl(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Preparing human-readable dictionary for ssl certificate command.

        :param results: ssl certificates details
        :return: human-readable dict
        """
        return [{
            'First (GMT)': epochToTimestamp(result.get('firstSeen', '')) if result.get('firstSeen') else None,
            'Last (GMT)': epochToTimestamp(result.get('lastSeen', '')) if result.get('lastSeen') else None,
            'SSL Version': result.get('sslVersion', 0),
            'Expires (GMT)': result.get('expirationDate', ''),
            'Issued (GMT)': result.get('issueDate', ''),
            'Sha1': result.get('sha1', ''),
            'Serial Number': result.get('serialNumber', ''),
            'Subject Country': result.get('subjectCountry', ''),
            'Issuer Common Name': result.get('issuerCommonName', ''),
            'Issuer Province': result.get('issuerProvince', ''),
            'Subject State/Province Name': result.get('subjectStateOrProvinceName', ''),
            'Subject Street Address': result.get('subjectStreetAddress', ''),
            'Issuer State/Province Name': result.get('issuerStateOrProvinceName', ''),
            'Issuer Country': result.get('issuerCountry', ''),
            'Subject Locality Name': result.get('subjectLocalityName', ''),
            'Subject Alternative Names': ', '.join(result.get('subjectAlternativeNames', [])),
            'Issuer Organization Unit Name': result.get('issuerOrganizationUnitName', ''),
            'Issuer Organization Name': result.get('issuerOrganizationName', ''),
            'Subject Organization Name': result.get('subjectOrganizationName', ''),
            'Issuer Locality Name': result.get('issuerLocalityName', ''),
            'Subject Common Name': result.get('subjectCommonName', ''),
            'Subject Province': result.get('subjectProvince', ''),
            'Subject Organization Unit Name': result.get('subjectOrganizationUnitName', ''),
            'Issuer Street Address': result.get('issuerStreetAddress', '')
        } for result in results]


    def prepare_human_readable_dict_for_pdns(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Prepare human-readable dictionary for passive DNS command.

        :param results: passive DNS details.
        :return: human-readable dict
        """
        return [{
            'First (GMT)': result.get('firstSeen', ''),
            'Last (GMT)': result.get('lastSeen', ''),
            'Source': ', '.join(result.get('source', [])),
            'Value': result.get('value', ''),
            'Collected (GMT)': result.get('collected', ''),
            'Record Type': result.get('recordType', ''),
            'Resolve': result.get('resolve', ''),
            'Resolve Type': result.get('resolveType', ''),
            'Record Hash': result.get('recordHash', '')
        } for result in results]


    def get_ssl_cert_search_hr(results: List[Dict[str, Any]]) -> str:
        """
        Retrieved information of ssl certificates and convert it into human-readable markdown string.

        :param results: ssl certificates details
        :return: human-readable string
        """
        ssl_cert_search_hr: List[Dict[str, Any]] = prepare_human_readable_dict_for_ssl(results)

        hr = '### Total Retrieved Record(s): ' + str(len(results)) + '\n'
        hr += tableToMarkdown('SSL certificate(s)', ssl_cert_search_hr,
                              ['Sha1', 'Serial Number', 'Issued (GMT)', 'Expires (GMT)', 'SSL Version', 'First (GMT)',
                               'Last (GMT)', 'Issuer Common Name', 'Subject Common Name', 'Subject Alternative Names',
                               'Issuer Organization Name', 'Subject Organization Name', 'Issuer Locality Name',
                               'Subject Locality Name', 'Issuer State/Province Name', 'Subject State/Province Name',
                               'Issuer Country', 'Subject Country', 'Issuer Street Address', 'Subject Street Address',
                               'Issuer Organization Unit Name', 'Subject Organization Unit Name'], removeNull=True)

        return hr


    def get_pdns_details_hr(results: List[Dict[str, Any]], total_record: int) -> str:
        """
        Retrieved information of passive DNS and convert it into human-readable markdown string.

        :param results: passive DNS details
        :param total_record: number of record retrieved from response
        :return: human-readable string
        """
        pdns_details_hr: List[Dict[str, Any]] = prepare_human_readable_dict_for_pdns(results)

        table_headers = ['Resolve', 'Resolve Type', 'Record Type', 'Collected (GMT)', 'First (GMT)', 'Last (GMT)',
                         'Source', 'Record Hash']
        hr = '### Total Retrieved Record(s): ' + str(total_record) + '\n'
        hr += tableToMarkdown('PDNS detail(s)', pdns_details_hr, table_headers, removeNull=True)
        return hr


    def create_pdns_standard_context(results: List[Dict[str, Any]]) -> List[CommandResults]:
        """
        Preparing standard context and dbotScore for pdns command.
        here, standard context includes ip and domain model.

        :param results: pdns details from response
        :return: list of CommandResults of standard context
        """
        standard_results: List[CommandResults] = []
        for result in results:
            resolve_type = result.get('resolveType', '')
            resolve = result.get('resolve', '')

            if 'domain' == resolve_type:
                dbot_score = Common.DBotScore(resolve, resolve_type, INTEGRATION_NAME, Common.DBotScore.NONE)
                if auto_detect_indicator_type(resolve) == FeedIndicatorType.Domain:
                    domain_ioc = Common.Domain(resolve, dbot_score)
                    # add standard output with standard readable output
                    standard_results.append(CommandResults(
                        indicator=domain_ioc,
                        readable_output=tableToMarkdown('', domain_ioc.to_context().get(Common.Domain.CONTEXT_PATH))
                    ))
            elif 'ip' == resolve_type:
                dbot_score = Common.DBotScore(resolve, resolve_type, INTEGRATION_NAME, Common.DBotScore.NONE)
                if auto_detect_indicator_type(resolve) == FeedIndicatorType.IP:
                    ip_ioc = Common.IP(resolve, dbot_score)
                    # add standard output with standard readable output
                    standard_results.append(CommandResults(
                        indicator=ip_ioc,
                        readable_output=tableToMarkdown('', ip_ioc.to_context().get(Common.IP.CONTEXT_PATH))
                    ))

        return standard_results


    def get_services_hr(total_records: int, results: list) -> str:
        services_hr = []
        for result in results:
            current_services = result.get("currentServices", [])
            labels = []
            for services in current_services:
                if services.get("label"):
                    labels.append(services.get("label"))

            services_hr.append({
                "Port Number": result.get("portNumber"),
                "Protocol": result.get("protocol"),
                "Status": result.get("status"),
                "Current Service Labels": ", ".join(labels),
                "First Seen Date (GMT)": result.get("firstSeen"),
                "Last Seen Date (GMT)": result.get("lastSeen"),
                "Last Scanned Date (GMT)": result.get("lastScan")
            })

        table_output = tableToMarkdown("Services", services_hr,
                                       headers=["Port Number", "Protocol", "Status", "Current Service Labels",
                                                "First Seen Date (GMT)", "Last Seen Date (GMT)", "Last Scanned Date (GMT)"],
                                       removeNull=True)

        return f"### Total Retrieved Record(s) {total_records} \n {table_output}"


    def validate_get_cookies_arguments(args: Dict[str, Any]) -> None:
        """
        Validate arguments for get cookies command, raise ValueError on invalid arguments.

        :param args: stripped arguments provided by user
        """

        # check if page is a valid whole number
        try:
            if int(args.get("page", "0")) < 0:
                raise ValueError
        except ValueError:
            raise ValueError(MESSAGES['INVALID_WHOLE_NUMBER'].format('page'))

        # check if the single-select values of arguments are valid or not
        valid_values = {
            'search_by': [
                'get addresses by cookie domain',
                'get addresses by cookie name',
                'get hosts by cookie domain',
                'get hosts by cookie name'
            ],
            'order': [
                'desc',
                'asc'
            ],
            'sort': [
                'first seen',
                'last seen'
            ]
        }
        for argument_name, valid_value in valid_values.items():
            if args.get(argument_name) not in valid_value:
                raise ValueError(MESSAGES['INVALID_SINGLE_SELECT'].format(argument_name, ",".join(valid_value)))

        # validate query param based on search_by
        if "domain" in args['search_by']:
            # The domain should only contain the characters a-z, A-Z, hyphen (-) and fullstops (.).
            if not args["query"] or re.search("[^a-zA-Z0-9.-]", args['query']):
                raise ValueError(MESSAGES['INVALID_QUERY_COOKIE_DOMAIN'])
        else:
            """ Valid cookie name can be any US-ASCII characters,
                except control characters, spaces, separator character or tabs."""
            if not args["query"] or re.search(r'[?^()<>@,;:/="\[\]{}\\\t\n\s]', args["query"]):
                raise ValueError(MESSAGES['INVALID_QUERY_COOKIE_NAME'])


    def get_cookies_hr(results: List[Dict[str, Any]], hostname_header: str, total_records: int):
        """
        Retrieved information of cookies and convert it into human-readable markdown string.

        :param results: cookie details
        :param hostname_header: The header for the hostname column, should be either 'Hostname' or 'IP Address'
        :param total_records: Total number of available records
        :return: human-readable string
        """
        hr_results = [{
            hostname_header: result.get("hostname", ''),
            'Cookie Name': result.get("cookieName", ''),
            'Cookie Domain': result.get("cookieDomain", ''),
            'First Seen Date (GMT)': result.get("firstSeen", ''),
            'Last Seen Date (GMT)': result.get("lastSeen", '')
        } for result in results]

        table_headers = [hostname_header, 'Cookie Name', 'Cookie Domain', 'First Seen Date (GMT)', 'Last Seen Date (GMT)']

        hr = '### Total Record(s): ' + str(total_records) + '\n'
        hr += '### Total Retrieved Record(s): ' + str(len(hr_results)) + '\n'
        hr += tableToMarkdown('Cookies', hr_results, table_headers, removeNull=True)
        return hr


    ''' REQUESTS FUNCTIONS '''


    def test_function(client: Client) -> str:
        """
        Performs test connectivity by valid http response

        :param client: client object which is used to get response from api
        :return: raise ValueError if any error occurred during connection
        """
        client.http_request(method='GET', url_suffix=URL_SUFFIX['TEST_MODULE'])

        return 'ok'


    @logger
    def get_components_command(client: Client, args: Dict[str, Any]) -> Union[str, List[CommandResults]]:
        """
        Retrieves the host attribute components for a domain or IP address.

        :param client: Client object
        :param args: The command arguments provided by user
        :return: Standard command result or no records found message
        """
        # Trim the arguments
        for argument in args:
            args[argument] = args[argument].strip()

        # Retrieve arguments and prepare query data
        params = get_common_arguments(args)

        # http call
        resp = client.http_request(method="GET", url_suffix=URL_SUFFIX['GET_COMPONENTS'], params=params)

        total_records = resp.get('totalRecords', 0)
        if total_records == 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('component(s)')

        results = resp.get('results', [])

        # Creating entry context
        command_results, custom_ec = get_host_attribute_context_data(results)

        # Creating human-readable
        hr = get_components_hr(results)

        command_results.insert(0, CommandResults(
            outputs_prefix='PassiveTotal.Component',
            outputs_key_field='',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp,
        ))

        return command_results


    @logger
    def pt_whois_search_command(client_obj: Client, args: Dict[str, Any]) -> Union[List[CommandResults], str]:
        """
        Gets WHOIS information records based on field matching queries

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-whois-search
        :return: command output
        """
        # Retrieve arguments
        query, field = get_valid_whois_search_arguments(args)
        params = {
            'query': query,
            'field': field
        }

        # http call
        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['WHOIS_SEARCH'], params=params)

        domains = response.get('results', [])
        if len(domains) <= 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('domain information')

        # Creating entry context
        command_results, custom_ec = get_context_for_whois_commands(domains)

        # Creating human-readable
        hr = get_human_readable_for_whois_commands(domains)

        command_results.insert(0, CommandResults(
            outputs_prefix='PassiveTotal.WHOIS',
            outputs_key_field=['domain', 'lastLoadedAt'],
            outputs=custom_ec,
            readable_output=hr,
            raw_response=response
        ))

        return command_results


    @logger
    def get_trackers_command(client: Client, args: Dict[str, Any]) -> Union[str, List[CommandResults]]:
        """
        Retrieves the host attribute trackers for a domain or IP address.

        :param client: Client object
        :param args: The command arguments provided by user
        :return: Standard command result or no records found message
        """
        # Trim the arguments
        for argument in args:
            args[argument] = args[argument].strip()

        # Retrieve arguments and prepare query data
        params = get_common_arguments(args)

        # http call
        resp = client.http_request(method="GET", url_suffix=URL_SUFFIX['GET_TRACKERS'], params=params)

        total_records = resp.get('totalRecords', 0)
        if total_records == 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('tracker(s)')

        results = resp.get('results', [])

        # Creating entry context
        command_results, custom_ec = get_host_attribute_context_data(results)

        # Creating human-readable
        hr = get_trackers_hr(results)

        command_results.insert(0, CommandResults(
            outputs_prefix='PassiveTotal.Tracker',
            outputs_key_field='',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp,
        ))

        return command_results


    @logger
    def ssl_cert_search_command(client: Client, args: Dict[str, Any]) -> Union[str, CommandResults]:
        """
        Retrieve SSL certificates based on various field and its value.

        :param client: client object.
        :param args: Demisto argument(s) provided by the user.
        :return: standard command result
        """
        # Retrieve arguments
        field: str = args.get('field', '')
        query: str = args.get('query', '')

        # Building url
        url_suffix: str = URL_SUFFIX['SSL_CERT_SEARCH']

        # Prepare query data
        request_data: Dict[str, Any] = {
            'field': field,
            'query': query
        }

        # http call
        resp: Dict[str, Any] = client.http_request("GET", url_suffix, request_data)

        results: List[Dict[str, Any]] = resp.get('results', [])
        if len(results) <= 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('SSL certificate(s)')

        # Creating entry context
        custom_ec = createContext(results, removeNull=True)

        # Creating human-readable
        hr = get_ssl_cert_search_hr(results)

        return CommandResults(
            outputs_prefix='PassiveTotal.SSL',
            outputs_key_field='sha1',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp
        )


    @logger
    def get_pdns_details_command(client: Client, args: Dict[str, Any]) -> Union[str, List[CommandResults]]:
        """
        Retrieve passive DNS details based on ip or host.

        :param client: client object.
        :param args: Demisto argument(s) provided by the user.
        :return: standard command result
        """
        # Retrieve arguments
        params = get_common_arguments(args)
        params['timeout'] = args.get('timeout', 7)

        # http call
        resp = client.http_request("GET", url_suffix=URL_SUFFIX['GET_PDNS_DETAILS'], params=params)
        total_record = resp.get('totalRecords', 0)
        if total_record <= 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('PDNS Record(s)')

        # Creating entry context
        results = resp.get('results', [])
        custom_ec = createContext(results, removeNull=True)
        command_results = create_pdns_standard_context(results)

        # Creating human-readable
        hr = get_pdns_details_hr(results, total_record)

        # Building custom output path
        output_path = 'PassiveTotal.PDNS(val.{0} == obj.{0} && val.{1} == obj.{1} && val.{2} == obj.{2})' \
            .format('resolve', 'recordType', 'resolveType')

        command_results.insert(0, CommandResults(
            outputs_prefix=output_path,
            outputs_key_field='',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp
        ))

        return command_results


    @logger
    def get_host_pairs_command(client: Client, args: Dict[str, Any]) -> Union[str, CommandResults]:
        """
        Retrieves the host attribute pairs related to a domain or IP address.

        :param client: Client object
        :param args: The command arguments provided by user
        :return: Standard command result or no records found message
        """
        # Trim the arguments
        for argument in args:
            args[argument] = args[argument].strip()

        # Retrieve arguments and prepare query data
        params = get_common_arguments(args)

        if args.get('direction') not in VALID_DIRECTION_FOR_HOST_PAIRS:
            raise ValueError(MESSAGES['INVALID_DIRECTION_VALUE'])
        params['direction'] = args.get('direction')

        # http call
        resp = client.http_request(method="GET", url_suffix=URL_SUFFIX['GET_HOST_PAIRS'], params=params)

        total_records = resp.get('totalRecords', 0)
        if total_records == 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('host pair(s)')

        results = resp.get('results', [])

        # Creating entry context
        custom_ec = createContext(data=results, removeNull=True)

        # Creating human-readable
        hr = get_host_pairs_hr(results)

        return CommandResults(
            outputs_prefix='PassiveTotal.HostPair',
            outputs_key_field='',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp
        )


    @logger
    def domain_reputation_command(client_obj: Client, args: Dict[str, Any]) -> Union[str, List[CommandResults]]:
        """
        Reputation command for domain.

        :param client_obj: Client object
        :param args: The command arguments provided by user
        :return: Standard command result or no records found message
        """
        # Retrieve arguments
        domains = argToList(args.get('domain', ''))

        # argument validation
        if len(domains) == 0:
            raise ValueError('domain(s) not specified')

        command_results: List[CommandResults] = []
        custom_domain_context: List[Dict[str, Any]] = []
        domain_responses: List[Dict[str, Any]] = []

        for domain in domains:
            # argument validation
            if domain.strip() == '':
                raise ValueError(MESSAGES['EMPTY_DOMAIN_ARGUMENT'])

            params = {
                'query': domain,
                'field': 'domain'
            }

            # http call
            response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['WHOIS_SEARCH'], params=params)

            domains_response = response.get('results', [])
            if len(domains_response) <= 0:
                continue

            # Creating entry context
            standard_results, custom_context = get_context_for_whois_commands(domains_response)
            command_results.extend(standard_results)
            custom_domain_context += custom_context
            domain_responses += domains_response

        # Creating human-readable
        domain_standard_hr = get_human_readable_for_whois_commands(
            domain_responses,
            is_reputation_command=True
        )

        command_results.insert(0, CommandResults(
            readable_output=domain_standard_hr,
            outputs_prefix='PassiveTotal.Domain',
            outputs_key_field='domain',
            outputs=custom_domain_context,
        ))

        return command_results


    @logger
    def get_services_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the services for the specified IP address.

        :param client: Client object.
        :param args: The command arguments provided by user.
        :return: Standard command result or no records found message.
        """

        # Trim the argument and remove ' quotes surrounding ip
        ip = args['ip'].strip().strip("'")

        # Checking whether ip is valid or not
        if not is_ip_valid(ip, accept_v6_ips=True):
            raise ValueError(MESSAGES['INVALID_IP'])

        # http call
        resp = client.http_request(method="GET", url_suffix=URL_SUFFIX['GET_SERVICES'], params={'query': ip})

        total_records = resp.get('totalRecords', 0)

        if total_records == 0:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('services'))

        results = [{**response, 'ip': ip} for response in resp.get('results', [])]

        # Creating context
        context_output = remove_empty_elements(results)

        # Creating human-readable
        hr = get_services_hr(total_records, results)

        return CommandResults(
            outputs_prefix='PassiveTotal.Service',
            outputs_key_field=['ip', 'portNumber'],
            outputs=context_output,
            readable_output=hr,
            raw_response=resp,
        )


    @logger
    def pt_get_whois_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Gets WHOIS information records based on queries

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-get-whois
        :return: command output
        """
        # Retrieve arguments
        query, history = get_valid_get_whois_arguments(args)
        params = {
            'query': query,
            'history': history
        }

        # http call
        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['WHOIS_GET'], params=params)

        domains = response.get('results', [])
        if len(domains) <= 0 and 'domain' in response:
            domains = [response]

        if len(domains) <= 0:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('domain information'))

        # Creating entry context
        custom_context = get_context_for_get_whois_commands(domains)

        # Creating human-readable
        hr = get_human_readable_for_whois_commands(domains)

        return CommandResults(
            outputs_prefix='PassiveTotal.WHOIS',
            outputs_key_field=['domain', 'lastLoadedAt'],
            outputs=custom_context,
            readable_output=hr,
            raw_response=response
        )


    @logger
    def get_cookies_command(client: Client, args: Dict[str, str]) -> Union[str, CommandResults]:
        """
        Retrieve cookies with hostnames or addresses based on cookie name or cookie domain.

        :param client: Client object
        :param args: The command arguments provided by user

        :return: Standard command result or no records found message
        """

        default_values = {
            'page': "0",
            'sort': "last seen",
            'order': 'desc'
        }
        # Trim the arguments and fill empty optional args with default values
        for argument in args:
            args[argument] = args[argument].strip()
            if not args[argument] and argument in list(default_values.keys()):
                args[argument] = default_values[argument]

        # Validate arguments
        validate_get_cookies_arguments(args)

        # Prepare params for http request
        params = {
            "page": args.get("page"),
            "sort": 'lastSeen' if args.get("sort") == "last seen" else 'firstSeen',
            "order": args.get("order")
        }

        # Prepare the url suffix as per search_by and query argument
        url_suffix = URL_SUFFIX["_".join(args["search_by"].upper().split())].format(args["query"])

        # Make the http request
        resp = client.http_request(method="GET", url_suffix=url_suffix, params=params)

        # Get results from response
        results = resp.get("results", [])

        # Get total records from response
        total_records = resp.get("totalRecords", 0)
        # return standard no records found message on empty results
        if len(results) <= 0:
            return 'Total Record(s): ' + str(total_records) + '\n' + MESSAGES['NO_RECORDS_FOUND'].format('cookies')

        # creating entry context
        entry_context = createContext(results, removeNull=True)

        # create human readable by providing it results and the first column header name
        human_readable = get_cookies_hr(results, "Hostname" if "hosts" in url_suffix else "IP Address", total_records)

        # return CommandResults objects
        return CommandResults(
            outputs_prefix="PassiveTotal.Cookie",
            outputs_key_field=['hostname', 'cookieName', 'cookieDomain'],
            outputs=entry_context,
            readable_output=human_readable,
            raw_response=resp
        )


    @logger
    def pt_get_articles_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Gets an article information based on queries

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-get-articles
        :return: command output
        """
        # Retrieve arguments
        query = args.get('query', '').strip()
        article_type = args.get('type', '').strip()
        if query == '':
            raise ValueError(MESSAGES['EMPTY_GET_WHOIS_ARGUMENT'])

        params = {
            'query': query
        }

        if article_type != '':
            params['type'] = article_type

        # http call
        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['GET_ARTICLES'], params=params)

        articles = response.get('articles', [])

        if not articles or len(articles) <= 0:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('articles'))

        # Creating entry context
        custom_ec_for_articles = remove_empty_elements(articles)

        # Creating human-readable
        hr = get_human_readable_for_articles_commands(articles)

        return CommandResults(
            outputs_prefix='PassiveTotal.Article',
            outputs_key_field='guid',
            outputs=custom_ec_for_articles,
            readable_output=hr,
            raw_response=response
        )


    def main() -> None:
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        # Commands dict
        commands = {
            'pt-ssl-cert-search': ssl_cert_search_command,
            'pt-get-pdns-details': get_pdns_details_command,
            'pt-whois-search': pt_whois_search_command,
            'pt-get-components': get_components_command,
            'pt-get-trackers': get_trackers_command,
            'pt-get-host-pairs': get_host_pairs_command,
            'pt-get-services': get_services_command,
            'domain': domain_reputation_command,
            'pt-get-whois': pt_get_whois_command,
            'pt-get-cookies': get_cookies_command,
            'pt-get-articles': pt_get_articles_command
        }

        command = demisto.command()
        demisto.debug(f'Command being called is {command}')
        try:
            # Retrieve XSOAR params
            base_url = demisto.params().get('url')
            username = demisto.params().get('username')
            secret = demisto.params().get('secret')
            verify_certificate = not demisto.params().get('insecure', False)
            proxy = demisto.params().get('proxy', False)
            request_timeout = get_request_timeout()

            # prepare client class object
            client = Client(base_url=base_url, request_timeout=request_timeout, verify=verify_certificate, proxy=proxy,
                            auth=(username, secret))

            # This is the call made when pressing the integration Test button.
            if demisto.command() == 'test-module':
                result = test_function(client)
                demisto.results(result)
            elif command in commands:
                return_results(commands[command](client, demisto.args()))

        # Log exceptions
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Error: {str(e)}')


    def init():
        if __name__ in ('__main__', '__builtin__', 'builtins'):
            main()


    init()
  subtype: python3
  type: python
system: true
